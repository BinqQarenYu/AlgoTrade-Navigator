
'use server';
/**
 * @fileOverview An AI agent for ranking potential trade signals.
 *
 * - rankSignals - A function that takes a list of signals and ranks them.
 * - RankSignalsInput - The input type for the rankSignals function.
 * - RankSignalsOutput - The return type for the rankSignals function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

// This schema defines the structure of a single trade signal for the AI.
const TradeSignalSchema = z.object({
  asset: z.string().describe("The asset symbol, e.g., BTCUSDT."),
  action: z.enum(['UP', 'DOWN']).describe("The recommended trade direction: UP for long, DOWN for short."),
  entryPrice: z.number().describe("The approximate price to enter the trade."),
  stopLoss: z.number().describe("The price at which to exit the trade for a loss."),
  takeProfit: z.number().describe("The price at which to exit the trade for a profit."),
  confidence: z.number().min(0).max(1).describe("The confidence level of the signal from its source AI, if applicable."),
  reasoning: z.string().describe("The rationale provided by the original strategy or AI that generated this signal."),
  timestamp: z.date().describe("The timestamp when the signal was generated."),
  strategy: z.string().describe("The name of the strategy that generated this signal."),
  peakPrice: z.number().optional().describe("The price of the structural peak/low that this signal is based on, if applicable."),
});

const RankSignalsInputSchema = z.object({
  signals: z.array(TradeSignalSchema).describe('An array of potential trade signals to be ranked.'),
  marketContext: z.string().describe('General market context, like the Fear & Greed Index value.'),
});
export type RankSignalsInput = z.infer<typeof RankSignalsInputSchema>;

const RankedSignalSchema = TradeSignalSchema.extend({
    rank: z.number().int().min(1).describe('The rank of the signal, where 1 is the best.'),
    justification: z.string().describe('A concise justification for why this signal was given its rank, considering its individual strength and its standing relative to the other signals provided.'),
});

const RankSignalsOutputSchema = z.object({
  rankedSignals: z.array(RankedSignalSchema),
});
export type RankSignalsOutput = z.infer<typeof RankSignalsOutputSchema>;

export async function rankSignals(input: RankSignalsInput): Promise<RankSignalsOutput> {
  return rankSignalsFlow(input);
}

const prompt = ai.definePrompt({
  name: 'rankSignalsPrompt',
  input: {schema: RankSignalsInputSchema},
  output: {schema: RankSignalsOutputSchema},
  prompt: `You are a Head Trader at a quantitative hedge fund. You have received several trade proposals from your junior analysts (each proposal is a "signal" generated by a specific strategy). Your task is to analyze all proposals, rank them from best to worst, and provide a clear justification for each rank.

**Current Market Context:**
{{marketContext}}

**Trade Proposals to Evaluate:**
{{#each signals}}
- **Signal for {{asset}} (Strategy: {{strategy}})**
  - Direction: {{action}}
  - Entry: {{entryPrice}}
  - Stop-Loss: {{stopLoss}}
  - Take-Profit: {{takeProfit}}
  - Analyst's Reasoning (from strategy): {{reasoning}}
  - AI Confidence (if applicable): {{confidence}}
{{/each}}

**Your Task:**
1.  **Evaluate each signal individually.** Consider the strategy that generated it. Is it a trend-following or mean-reversion signal? Does the reasoning make sense?
2.  **Compare signals against each other.** A key part of your job is resource allocation. Which trade offers the best risk/reward? Is there any confluence (e.g., two different strategies signaling a BUY on the same asset)? Confluence is a very strong indicator.
3.  **Consider the overall market context.** A strong "BUY" signal might be less attractive in a "Extreme Fear" market, unless it's a clear mean-reversion play.
4.  **Provide a ranked list.** Return all the signals you were given, but add a 'rank' and a 'justification' for each. The rank should be a number starting from 1 for the best signal. The justification should be concise and explain your thought process for that specific signal's rank.

Provide the output in the required JSON format.
`,
});

const rankSignalsFlow = ai.defineFlow(
  {
    name: 'rankSignalsFlow',
    inputSchema: RankSignalsInputSchema,
    outputSchema: RankSignalsOutputSchema,
  },
  async input => {
    const maxRetries = 3;
    let lastError: Error | null = null;
    for (let i = 0; i < maxRetries; i++) {
      try {
        const { output } = await prompt(input);
        if (!output) {
            throw new Error("The AI model did not return a valid response. This could be due to safety filters or an internal error.");
        }
        return output;
      } catch (e: any) {
        lastError = e;
        // Check for common transient errors
        if (e.message && (e.message.includes('503') || e.message.includes('overloaded'))) {
          console.log(`Attempt ${i + 1} failed with a transient error. Retrying in ${Math.pow(2, i)}s...`);
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
        } else {
          // It's a different error, don't retry
          throw e;
        }
      }
    }
    // If all retries failed
    throw new Error(`AI model call failed after ${maxRetries} attempts. Last error: ${lastError?.message}`);
  }
);
